## javascript运行机制
### CPU、进程和线程
**1.CPU**
计算机的核心是CPU，它承担了所有的计算任务。
**2.进程**
cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
**3.线程**
是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
>浏览器是多进程的，每一个tab页，就是一个独立的进程，一个进程可以有多个线程
### 浏览器进程
* 主进程
  * ...
* 第三方插件进程
  * ...
* GPU进程
  * `渲染进程`，也就是常说的`浏览器内核`
  * ...
### 浏览器内核（渲染进程）
>进程和线程是一对多的关系，也就是说一个进程包含了多条线程。

渲染进程也是多线程的：
* `GUI渲染线程`
  * 负责渲染页面，布局和绘制
  * 页面需要重绘和回流时，该线程就会执行
  * 与js引擎线程互斥，防止渲染结果不可预期
* `js引擎线程`
  * 负责处理解析和执行javascript脚本程序
  * 只有一个JS引擎线程（单线程）
  * 与GUI渲染线程互斥，防止渲染结果不可预期
* `事件触发线程`
  * 用来控制事件循环（鼠标点击、setTimeout、ajax等）
  * 当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中
* `定时触发器线程`
  * setInterval与setTimeout所在的线程
  * 定时任务并不是由JS引擎计时的，是由定时触发线程来计时的
  * 计时完毕后，通知事件触发线程
* `异步http线程`
  * 浏览器有一个单独的线程用于处理AJAX请求
  * 当请求完成时，若有回调函数，通知事件触发线程

### 为什么javascript是单线程的？
* 1.历史原因，在创建javascript这门语言时，多进程多线程的架构并不流行，硬件支持并不好。
* 2.多线程操作需要加锁，编码的复杂性增高
* 3.如果同时操作DOM，不加锁的情况下，DOM渲染的结果不可预测
### 为什么 GUI 渲染线程与 JS 引擎线程互斥？
因为js是可以操作DOM的，如果同时修改元素属性并渲染界面（`js引擎线程`和`GUI线程`同时运行），那么渲染线程前后获得的元素就可能不一致了。所以为了防止渲染出现不可预测的结果，浏览器设定`js引擎线程`和`GUI线程`互斥，当`js引擎线程`执行时`GUI渲染线程`会被挂起，GUI更新则会被保存在一个队列中等待JS引擎线程空闲时立即被执行。
### 从 Event Loop 看 JS 的运行机制
基本概念：
* js分为同步任务和异步任务
* 同步任务都在JS引擎线程上执行，形成一个`执行栈`
* 事件触发线程管理一个`任务队列`，异步任务触发条件达成，将回调事件放到`任务队列`中
* `执行栈`中所有同步任务执行完毕，此时`js引擎线程`空闲，系统会读取`事件队列`,将可运行的异步任务回调事件添加到`执行栈`中，开始执行

不管是`setTimeout/setInterval`还是`xhr/fetch`代码，在这些代码执行时，本身是同步任务，其中的回调函数才是异步任务。
**setTimeout/setInterval**
代码执行到`setTimeout/setInterval`时，`js引擎线程`通知`定时触发器线程`,间隔一个时间后，会触发一个回调事件，而`定时触发器线程`在接收到这个消息后，会在等待的时间后，将回调事件放入到由`事件触发线程`管理的`事件队列`中
**xhr/fetch**
执行xhr/fetch时，`js引擎线程`会通知`异步http线程`，发送一个网络请求，并制定请求完成后的回调事件，而`异步http线程`在接收到这个消息后，会在请求完成后，将回调事件放入到由`事件触发线程`管理的`事件队列`中

当我们的同步任务执行完，`JS引擎线程`会询问`事件触发线程`，在`事件队列中`是否有待执行的回调函数，如果有就会加入到`执行栈`中交给`JS引擎线程`执行
### 宏任务与微任务
**宏任务**
每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）， 每一个宏任务会从头到尾执行完毕，不会执行其他。
会在一个宏任务执行结果后，在下一个宏任务执行前，GUI渲染线程开始工作，对页面进行渲染。
>宏任务 -->渲染 -->宏任务 -->渲染...

主代码块，setTimeout，setInterval等，都属于宏任务
**微任务**
`宏任务`结束后，会执行渲染，然后执行下一个`宏任务`,而`微任务`可以理解成在当前`宏任务`执行后立即执行的任务，也就是说，当宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完。
Promise，process.nextTick等，属于微任务。

![](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7bb4bd9fd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

举例:
```js
function test() {
  setTimeout(() => {
    console.log(1)
  },0)
  Promise.resolve().then(() => {
    console.log(2)
  })
  console.log(3)
}
test()
console.log(4)
```
以上，整体代码是同步任务，执行test，test是同步，依次执行，遇到setTimeout，通知`定时触发器线程`，间隔一个时间后，会触发一个回调事件，`定时触发器线程`收到通知后，间隔一个时间，将回调事件放入到由`事件触发线程`管理的`任务队列`，然后继续执行test的代码，遇到`Promise.resolve().then`,`then()`里面的回调是一个异步任务，通知事件触发线程，将其加入到`任务队列`,test继续执行，打印3，test函数执行完毕，test出栈，当前执行栈为window，打印4，当前`宏任务`执行完毕，检查`任务队列`是否有任务，检查到有微任务，将微任务放到执行栈中执行，打印2，然后检查到有宏任务，将宏任务放到执行栈中执行，打印1。

>检查任务队列时，先微后宏，有事件回调，则移入执行栈由`js引擎线程`执行。